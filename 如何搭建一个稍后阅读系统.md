# 如何搭建一个稍后阅读系统

## （1）功能1：保存网页内容，防止网页内容失效

**目的**：我希望实现的功能是整个网页的内容保存为本地的markdowm文件，防止未来网页内容失效。

**工具**：使用Obsidian自带的`Web Clipper`即可。

**配置步骤**：在网页端的`Web Clipper`插件新建一个template，做如下设置：

![[attachments/4e62fee2e68f16dfc597ab31769bc1e5_MD5.jpeg|375]]
![[attachments/5cac9963696098daa69ba3d504c827da_MD5.jpeg|350]]
特别地，对于视频网页，保存的设置为：

![[attachments/f47663c072aad00fc8537c37936976dc_MD5.jpeg|400]]
![[attachments/b44ff0b00dde514d9942981d2745e49c_MD5.jpeg|400]]
## （2）功能2：保存标记的内容

**目的**：我希望实现的功能是高亮内容保存到另一个笔记库中。

**工具**：使用Obsidian自带的`Web Clipper`即可。

**配置步骤**：在网页端的`Web Clipper`插件新建一个template，做如下设置：

![[attachments/32d0e6a872d91a3e5f9128c5b5fb445b_MD5.jpeg|350]]

![[attachments/651140fcc824f3f0d881010aafeb6e0e_MD5.jpeg|350]]
## （3）将网页中的图片自动下载到本地，防止网页内容失效

**目的**：我希望实现的功能是网页中的图片自动下载到本地，防止网页内容失效

**工具**：使用插件`Local Images Plus`

## （4）在浏览器中就可以查看网页是否被收藏、状态是已读/未读/正在读

### 1. 利用`Templater`插件实现自动导出笔记库中的所有url字段，并标记状态（已读/未读/正在读）

V1版本（没有状态信息）：

```js
<%*
const now = new Date();
const pad = n => n.toString().padStart(2, '0');
const timestamp = `${now.getFullYear()}-${pad(now.getMonth()+1)}-${pad(now.getDate())}_${pad(now.getHours())}-${pad(now.getMinutes())}-${pad(now.getSeconds())}`;

const logFolderPath = 'utils/obsidian-urls/logs';

// 确保日志文件夹存在（递归创建）
async function ensureFolder(path) {
  if (!app.vault.getAbstractFileByPath(path)) {
    await app.vault.createFolder(path);
  }
}

await ensureFolder('utils');
await ensureFolder('utils/obsidian-urls');
await ensureFolder(logFolderPath);

const logFilePath = `${logFolderPath}/${timestamp}.md`;

async function appendLog(text) {
  let existing = '';
  const file = app.vault.getAbstractFileByPath(logFilePath);
  if (file) {
    existing = await app.vault.read(file);
  }
  await app.vault.modify(file || await app.vault.create(logFilePath, ''), existing + text + '\n');
}

// 记录开始
await appendLog(`# 导出日志\n- 时间: ${now.toLocaleString()}\n`);

// Step 1: 获取所有Markdown文件
const files = app.vault.getMarkdownFiles();
await appendLog(`- 读取Markdown文件数: ${files.length}`);

let urls = [];
let error = null;

try {
  for (const file of files) {
    const content = await app.vault.read(file);
    const match = content.match(/^url:\s*(.+)$/m);
    if (match) {
      const url = match[1].trim();
      if (!urls.includes(url)) urls.push(url);
    }
  }
  await appendLog(`- 提取到的URL数量: ${urls.length}`);

  // 确保目标文件夹存在
  const urlsFolderPath = 'utils/obsidian-urls';
  await ensureFolder(urlsFolderPath);

  // 写入 JSON 文件
  const jsonContent = JSON.stringify(urls, null, 2);
  const jsonFilePath = `${urlsFolderPath}/urls.json`;
  const existingJsonFile = app.vault.getAbstractFileByPath(jsonFilePath);
  if (existingJsonFile) {
    await app.vault.delete(existingJsonFile);
    await appendLog(`- 删除了旧文件 ${jsonFilePath}`);
  }
  await app.vault.create(jsonFilePath, jsonContent);
  await appendLog(`- 成功写入文件: ${jsonFilePath}`);

} catch(e) {
  error = e.message;
  await appendLog(`- 出错: ${error}`);
}

// 结束状态写入
await appendLog(error ? `- 状态: 失败` : `- 状态: 成功`);

%>
```

V2版本（有状态信息）

```js
<%*
const now = new Date();
const pad = n => n.toString().padStart(2, '0');
const timestamp = `${now.getFullYear()}-${pad(now.getMonth()+1)}-${pad(now.getDate())}_${pad(now.getHours())}-${pad(now.getMinutes())}-${pad(now.getSeconds())}`;

const logFolderPath = 'utils/obsidian-urls/logs';

// 创建目录
async function ensureFolder(path) {
  if (!app.vault.getAbstractFileByPath(path)) {
    await app.vault.createFolder(path);
  }
}

await ensureFolder('utils');
await ensureFolder('utils/obsidian-urls');
await ensureFolder(logFolderPath);

const logFilePath = `${logFolderPath}/${timestamp}.md`;

async function appendLog(text) {
  let existing = '';
  const file = app.vault.getAbstractFileByPath(logFilePath);
  if (file) {
    existing = await app.vault.read(file);
  }
  await app.vault.modify(file || await app.vault.create(logFilePath, ''), existing + text + '\n');
}

// 日志头
await appendLog(`# Export Log\n- Time: ${now.toLocaleString()}\n`);

const files = app.vault.getMarkdownFiles();
await appendLog(`- Markdown files found: ${files.length}`);

let urlEntries = [];
let error = null;

try {
  for (const file of files) {
    const content = await app.vault.read(file);
    const urlMatch = content.match(/^url:\s*(.+)$/m);
    const statusMatch = content.match(/^status:\s*(.+)$/m);

    if (urlMatch) {
      const url = urlMatch[1].replace(/^"+|"+$/g, '').trim();
      const rawStatus = statusMatch ? statusMatch[1].trim().toLowerCase() : '';
      let statusLabel = 'unread';

      if (rawStatus === 'readed') statusLabel = 'read';
      else if (rawStatus === 'reading') statusLabel = 'reading';

      if (!urlEntries.find(e => e.url === url)) {
        urlEntries.push({ url, status: statusLabel });
      }
    }
  }

  await appendLog(`- URLs extracted: ${urlEntries.length}`);

  const urlsFolderPath = 'utils/obsidian-urls';
  await ensureFolder(urlsFolderPath);

  const jsonFilePath = `${urlsFolderPath}/urls-with-status.json`;
  const existingJsonFile = app.vault.getAbstractFileByPath(jsonFilePath);
  if (existingJsonFile) {
    await app.vault.delete(existingJsonFile);
    await appendLog(`- Deleted old file: ${jsonFilePath}`);
  }

  await app.vault.create(jsonFilePath, JSON.stringify(urlEntries, null, 2));
  await appendLog(`- Wrote new file: ${jsonFilePath}`);

} catch (e) {
  error = e.message;
  await appendLog(`- Error: ${error}`);
}

await appendLog(error ? `- Status: FAILED` : `- Status: SUCCESS`);
%>

```

另外，我们可以设置`Templator`在笔记库启动的时候自动运行上述脚本来更新`urls.json`：
![[attachments/Pasted image 20250727115850.png|525]]

### 2. 使用`git`插件将笔记库上传到github，并设置为公开

### 3. 使用油猴脚本查看github上的urls.json文件，并与当前网页url做比较，在网页旁标记网页信息（是否被收藏、状态是已读/未读/正在读

V1版本（没有状态信息，只显示已收藏/未收藏）：

```js
// ==UserScript==
// @name         Obsidian URL Checker (Always Show)
// @namespace    http://tampermonkey.net/
// @version      0.2
// @description  在网页角落提示是否已收藏到 Obsidian（不论是否命中）
// @match        *://*/*
// @grant        GM_xmlhttpRequest
// @connect      raw.githubusercontent.com
// ==/UserScript==

(function () {
    'use strict';

    const urlListUrl = "https://raw.githubusercontent.com/Huangzh2001/Read_It_Later/main/obsidian-urls/urls.json";
    const currentUrl = window.location.href;

    GM_xmlhttpRequest({
        method: "GET",
        url: urlListUrl,
        onload: function (res) {
            try {
                let urls = JSON.parse(res.responseText);
                urls = urls.map(u => u.replace(/^"+|"+$/g, '').trim());

                const found = urls.some(u => currentUrl.startsWith(u));
                if (found) {
                    showNotice("✅ 已收藏于 Obsidian", "#2ecc71"); // 绿色
                } else {
                    showNotice("❌ 未收藏于 Obsidian", "#e74c3c"); // 红色
                }
            } catch (err) {
                console.error("[Obsidian URL Checker] JSON 解析失败", err);
                showNotice("⚠️ Obsidian 列表加载失败", "#f39c12");
            }
        },
        onerror: function (err) {
            console.error("[Obsidian URL Checker] 网络请求失败", err);
            showNotice("⚠️ 无法加载 Obsidian 列表", "#f39c12");
        }
    });

    function showNotice(text, bgColor = "#333") {
        const div = document.createElement("div");
        div.textContent = text;
        div.style.position = "fixed";
        div.style.bottom = "10px";
        div.style.right = "10px";
        div.style.backgroundColor = bgColor;
        div.style.color = "white";
        div.style.padding = "8px 12px";
        div.style.borderRadius = "8px";
        div.style.zIndex = "9999";
        div.style.fontSize = "14px";
        div.style.boxShadow = "0 0 5px rgba(0,0,0,0.3)";
        document.body.appendChild(div);
    }

})();

```

V2版本（显示已收藏/未收藏和状态信息）：
```js
// ==UserScript==
// @name         Obsidian URL Checker (with Status)
// @namespace    http://tampermonkey.net/
// @version      0.3
// @description  显示网页是否已被收藏至 Obsidian，并提示阅读状态（read / reading / unread）
// @match        *://*/*
// @grant        GM_xmlhttpRequest
// @connect      raw.githubusercontent.com
// ==/UserScript==

(function () {
    'use strict';

    const urlListUrl = "https://raw.githubusercontent.com/Huangzh2001/Read_It_Later/refs/heads/main/utils/obsidian-urls/urls-with-status.json";
    const currentUrl = window.location.href;

    GM_xmlhttpRequest({
        method: "GET",
        url: urlListUrl,
        onload: function (res) {
            try {
                const urlData = JSON.parse(res.responseText);

                // 查找是否匹配
                const match = urlData.find(entry => currentUrl.startsWith(entry.url));
                if (match) {
                    const status = match.status || 'unread';
                    const statusColorMap = {
                        read: '#2ecc71',      // green
                        reading: '#f1c40f',   // yellow
                        unread: '#e67e22'     // orange
                    };
                    const statusLabelMap = {
                        read: 'Read',
                        reading: 'Reading',
                        unread: 'Unread'
                    };

                    const color = statusColorMap[status] || '#3498db';
                    const label = statusLabelMap[status] || status;

                    showNotice(`✅ Saved to Obsidian (${label})`, color);
                } else {
                    showNotice(`❌ Not saved to Obsidian`, '#e74c3c');
                }

            } catch (err) {
                console.error("[Obsidian URL Checker] JSON 解析失败", err);
                showNotice("⚠️ Failed to parse Obsidian list", "#f39c12");
            }
        },
        onerror: function (err) {
            console.error("[Obsidian URL Checker] 网络请求失败", err);
            showNotice("⚠️ Failed to load Obsidian list", "#f39c12");
        }
    });

    function showNotice(text, bgColor = "#333") {
        const div = document.createElement("div");
        div.textContent = text;
        div.style.position = "fixed";
        div.style.bottom = "10px";
        div.style.right = "10px";
        div.style.backgroundColor = bgColor;
        div.style.color = "white";
        div.style.padding = "8px 12px";
        div.style.borderRadius = "8px";
        div.style.zIndex = "9999";
        div.style.fontSize = "14px";
        div.style.boxShadow = "0 0 5px rgba(0,0,0,0.3)";
        document.body.appendChild(div);
    }

})();

```

**注意**：这里`urlListUrl = "";`更改为你的`urls.json`文件在github仓库中的链接。

## （5）如何做视频时间戳笔记

使用工具：`JumpVideo`[^2]（这个不是插件，而是软件。使用的不是开源的那个）

## （6）AI系统

工具：`copilot插件`（能用的免费配置方法[^1]）

## （7）筛选出正在看/已看完/未看的笔记

**目的**：筛选出正在看/已看完/未看的笔记，方便我们点击

工具：`dataview`插件

使用方法：

1. 显示未看笔记的代码

```js
table status
from "Read It Later" or "Watch It Later"
where status != "readed" and status != "reading"
sort file.name asc
```

2. 显示已看笔记的代码

```js
table status
from "Read It Later" or "Watch It Later"
where status = "readed"
sort file.name asc
```

3. 显示


# Reference

[^1]: [满血版DeepSeek接入个人知识库！Obsidian + 火山引擎 配置方法教程_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1kHPieuEs8/?spm_id_from=333.337.search-card.all.click&vd_source=06168f390bae49c4867767c52a20e87c)
[^2]: [如何用OB做抖音，百度云盘，B站等所有网页的视频笔记。Obsdian做网页视频笔记最好的方式，一键生成时间戳和截图，学习效率MAX！哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1hjPyeyEMA/?spm_id_from=333.1387.homepage.video_card.click&vd_source=06168f390bae49c4867767c52a20e87c)
[^3]: [TGK的宝藏 (thegodofking.com)](https://www.thegodofking.com/)